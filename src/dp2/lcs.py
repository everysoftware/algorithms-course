"""
https://www.youtube.com/watch?v=U8gzm92fprI

Последовательность s называется подпоследовательностью последовательности a, если она может быть получена
из a путем удаления некоторых (или нуля) элементов без изменения порядка оставшихся элементов. Например,
[3, 6, 2] является подпоследовательностью последовательности [0, 3, 1, 6, 2, 2, 7].

Общей подпоследовательностью двух строк A и B называется такая последовательность символов,
которая является подпоследовательностью обеих строк. Например, общей подпоследовательностью для строк "AGGTAB"
и "GXTXAYB" будет "GTA".

Определить длину наибольшей общей подпоследовательности двух строк A и B.

Формат ввода
Две строки, состоящие из заглавных латинских букв, длиной не более 1000 символов.

Формат вывода
Одно число - длина наибольшей общей подпоследовательности.

Пример 1
Ввод:
AGGTAB
GXTXAYB
Вывод:
4
Пояснение: Наибольшая общая подпоследовательность: "GTAB"

Пример 2
Ввод:
ABCBDAB
BDCAB
Вывод:
4
Пояснение: Наибольшая общая подпоследовательность: "BCAB"
"""


def lcs_rec_helper(a: str, b: str, n: int, m: int) -> int:
    # Если одна из строк пустая, то длина общей подпоследовательности равна 0
    if n == 0 or m == 0:
        return 0
    # Если последние символы совпадают, то уменьшаем обе строки на 1
    elif a[n - 1] == b[m - 1]:
        return 1 + lcs_rec_helper(a, b, n - 1, m - 1)
    # Иначе берем максимум из двух вариантов:
    else:
        return max(lcs_rec_helper(a, b, n, m - 1), lcs_rec_helper(a, b, n - 1, m))


def lcs_rec(a: str, b: str) -> int:
    """
    Находит длину наибольшей общей подпоследовательности двух строк рекурсией.
    Сложность O(2^(min(N, M))), где N и M - длины строк A и B соответственно.
    """
    return lcs_rec_helper(a, b, len(a), len(b))


def lcs_dp(a: str, b: str) -> int:
    """
    Находит длину наибольшей общей подпоследовательности двух строк с использованием динамического программирования.
    Сложность O(N * M), где N и M - длины строк A и B соответственно.
    """
    n, m = len(a), len(b)
    length = [[0] * (m + 1) for _ in range(n + 1)]
    """length[i][j] - длина наибольшей общей подпоследовательности для строк a[:i] и b[:j]"""

    for i in range(n + 1):
        for j in range(m + 1):
            # Если одна из строк пустая, то длина общей подпоследовательности равна 0
            if i == 0 or j == 0:
                length[i][j] = 0
            # Если последние символы совпадают, то длина общей подпоследовательности увеличивается на 1
            elif a[i - 1] == b[j - 1]:
                length[i][j] = 1 + length[i - 1][j - 1]
            # Иначе берем максимум из двух вариантов:
            # 1. Уменьшаем строку a на 1
            # 2. Уменьшаем строку b на 1
            else:
                length[i][j] = max(length[i][j - 1], length[i - 1][j])

    return length[n][m]
