"""
Longest Increasing Subsequence

https://leetcode.com/problems/longest-increasing-subsequence/description/

Последовательность s называется подпоследовательностью последовательности a, если она может быть получена
из a путем удаления некоторых (или нуля) элементов без изменения порядка оставшихся элементов. Например,
[3, 6, 2] является подпоследовательностью последовательности [0, 3, 1, 6, 2, 2, 7].

Последовательность a_n называется возрастающей, если a[i] < a[i + 1] для всех 0 <= i < n. Например,
[1, 3, 4, 8] является возрастающей последовательностью.

Дан массив целых чисел. Найдите наибольшую возрастающую подпоследовательность в нем.

Пример:
Ввод
0 7 1 6 2
Вывод
0 1 2
"""

from bisect import bisect_left


def get_path(a: list[int], prev: list[int], tail_idx: list[int]) -> list[int]:
    """Восстановление пути. Сложность O(N)"""
    path = []
    t = tail_idx[-1]

    while t != -1:
        path.append(a[t])
        t = prev[t]

    return path[::-1]


def lis(a: list[int]) -> list[int]:
    """Нахождение НВП. Сложность O(NlogN)"""
    n = len(a)

    tail = []
    """tail[i] - последний элемент НВП длины i"""
    tail_idx = []
    """tail_idx[i] - индекс последнего элемента НВП длины i"""
    prev = [-1] * n
    """prev[i] - индекс предыдущего элемента НВП, которая заканчивается на элементе i"""

    # Перебираем элементы
    for i, x in enumerate(a):
        # Если текущий элемент больше последнего элемента НВП, то он может её продолжить
        if not tail or x > tail[-1]:
            # Запоминаем индекс предыдущего элемента НВП
            if tail_idx:
                prev[i] = tail_idx[-1]

            # Текущий элемент становится новым последним элементом НВП
            tail.append(x)
            tail_idx.append(i)

        # Если текущий элемент меньше или равен последнему элементу НВП, то он может её улучшить
        else:
            # Меньший элемент должен быть вставлен в НВП, чтобы она была как можно длиннее.
            # Например, a = [0, 7, 1, 6, 2]. Когда мы встречаем 1, то 1 должен заменить 7, чтобы НВП была
            # длиннее, так как элементов превосходящих 1 очевидно больше, чем элементов превосходящих 7.
            idx_to_insert = bisect_left(tail, x)

            # Запоминаем индекс предыдущего элемента НВП
            if idx_to_insert > 0:
                prev[i] = tail_idx[idx_to_insert - 1]

            # Заменяем найденный элемент НВП на текущий элемент
            tail[idx_to_insert] = x
            tail_idx[idx_to_insert] = i

    return get_path(a, prev, tail_idx)
