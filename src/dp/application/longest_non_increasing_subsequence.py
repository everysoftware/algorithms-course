"""
https://stepik.org/lesson/13257/step/6?unit=3442

Последовательность s называется подпоследовательностью последовательности a, если она может быть получена
из a путем удаления некоторых (или нуля) элементов без изменения порядка оставшихся элементов. Например,
[3, 6, 2] является подпоследовательностью последовательности [0, 3, 1, 6, 2, 2, 7].

Последовательность a_n называется невозрастающей, если a[i] >= a[i + 1] для всех 0 <= i < n. Например,
[8, 4, 4, 2] является невозрастающей последовательностью.

Дан массив целых чисел. Найдите наибольшую невозрастающую подпоследовательность в нем.

Ввод
0 7 1 6 2
Вывод
7 6 2
"""

from bisect import bisect_right

from .longest_increasing_subsequence import get_path


def lns(a: list[int]) -> list[int]:
    """
    Нахождение ННП. Сложность O(NlogN)

    Обратите внимание на использование bisect_right вместо bisect_left. Это связано с тем, что
    мы хотим вставить элемент после всех элементов, равных ему, чтобы ННП была как можно длиннее
    (невозрастающая подпоследовательность допускает повторяющиеся элементы).

    Также обратите внимание на то, что мы используем отрицательные значения для элементов ННП в
    bisect_right. Это связано с тем, что bisect-функции работают с возрастающими последовательностями,
    а у нас невозрастающая. Поиск в невозрастающей подпоследовательности эквивалентен поиску в
    возрастающей подпоследовательности с отрицательными значениями элементов.
    """
    n = len(a)

    tail = []
    """tail[i] - последний элемент ННП длины i"""
    tail_idx = []
    """tail_idx[i] - индекс последнего элемента ННП длины i"""
    prev = [-1] * n
    """prev[i] - индекс предыдущего элемента ННП, которая заканчивается на элементе i"""

    # Перебираем элементы
    for i, x in enumerate(a):
        # Если текущий элемент больше последнего элемента ННП, то он может её продолжить
        if not tail or x <= tail[-1]:
            # Запоминаем индекс предыдущего элемента ННП
            if tail_idx:
                prev[i] = tail_idx[-1]

            # Текущий элемент становится новым последним элементом ННП
            tail.append(x)
            tail_idx.append(i)

        # Если текущий элемент больше последнего элемента ННП, то он может её улучшить
        else:
            # Больший элемент должен быть вставлен в ННП, чтобы она была как можно длиннее.
            # Например, a = [0, 7, 1, 6, 2]. Когда мы встречаем 7, то 7 должен заменить 0, чтобы ННП
            # была длиннее, так как элементов меньших или равных 7 очевидно больше, чем элементов меньших
            # или равных 0.
            idx_to_insert = bisect_right(tail, -x, key=lambda y: -y)

            # Запоминаем индекс предыдущего элемента НВП
            if idx_to_insert > 0:
                prev[i] = tail_idx[idx_to_insert - 1]

            # Заменяем найденный элемент НВП на текущий элемент
            tail[idx_to_insert] = x
            tail_idx[idx_to_insert] = i

    return get_path(a, prev, tail_idx)
