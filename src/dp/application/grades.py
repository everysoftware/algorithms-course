"""
https://contest.yandex.ru/contest/32588/problems/A/

Краткая легенда для задачи - Илья Сергеевич решил выписать подряд оценки студентов программной инженерии
и найти среди них образовательное комбо: такую подпоследовательность, оценки в которой не убывают
(что свидетельствует о повышении уровня студентов ПИ) и имеет наибольшую длину.

После утомительного перебора экспоненциального числа вариантов Илья Сергеевич поручил Вам решить и
автоматизировать эту задачу.

Формат ввода
Во входных данных две строки - в первой содержится количество оценок, выписанных Ильёй Сергеевичем.
Во второй - непосредственно сами оценки. Считаем, что каждая оценка это целое число от 0 до 10,
количество оценок не превышает 1000.

Формат вывода
В качестве ответа нужно также вывести две строки: в первой - лучшая найденная длина образовательного
комбо, вторая - содержит само комбо (числа разделены пробелами). Оформление заголовков можно найти в
примерах.

Пример
Ввод
5
0 5 1 6 2
Вывод
Best length = 3
Best combo is: 0 1 2
"""


def get_path(grade: list[int], length: list[int], prev: list[int]) -> list[int]:
    """Восстановление пути. Сложность O(N)"""
    max_length_idx = 0
    for i, x in enumerate(length):
        if x >= length[max_length_idx]:
            max_length_idx = i

    path = []
    i = max_length_idx
    while i != -1:
        path.append(grade[i])
        i = prev[i]

    return path[::-1]


def grades(grade: list[int]) -> list[int]:
    """
    Решение задачи об оценках. Сложность O(N^2)

    Принцип решения:
    1. Динамическое программирование
    2. Для каждого элемента массива grade[i] находим максимальную длину неубывающей подпоследовательности,
    заканчивающейся на элементе i
    3. Для этого перебираем все элементы до i и сравниваем их с grade[i]
    4. Если grade[i] >= grade[j], то length[i] = max(length[i], length[j] + 1)
    5. Для восстановления пути используем массив prev, в котором храним индексы предыдущих элементов
    6. Восстанавливаем путь, начиная с элемента с максимальной длиной подпоследовательности
    7. Возвращаем путь
    """
    n = len(grade)
    length = [1] * n
    """length[i] - длина максимальной неубывающей подпоследовательности, заканчивающейся на элементе i"""
    prev = [-1] * n
    """prev[i] - индекс предыдущего элемента в подпоследовательности, заканчивающейся на элементе i"""

    # Перебираем длину подпоследовательности
    for i in range(n):
        # Перебираем концы подпоследовательности
        for j in range(i):
            # Если условие неубывания выполняется
            if grade[i] >= grade[j]:
                # Обновляем ответ
                if length[j] + 1 >= length[i]:
                    length[i] = length[j] + 1
                    prev[i] = j

    return get_path(grade, length, prev)
