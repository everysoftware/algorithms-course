"""Числа Фибоначчи"""

from functools import lru_cache

"""
def fib_rec(n: int) -> int:
    if n < 2:
        return n
    else:
        return fib_rec(n - 1) + fib_rec(n - 2)
"""


def fib_cache_helper(n: int, cache: dict[int, int]) -> int:
    if n < 2:
        return n

    if n not in cache:
        cache[n] = fib_cache_helper(n - 1, cache) + fib_cache_helper(n - 2, cache)

    return cache[n]


def fib_cache(n: int) -> int:
    """
    Рекурсивное вычисление числа Фибоначчи с кэшированием. Сложность O(N).
    По-другому, этот метод называется "мемоизация", "ленивое вычисление" или "динамическое программирование назад".
    Это метод оптимизации, который используется для ускорения программы, вычисляющей функцию с использованием
    рекурсии. Он заключается в сохранении результатов выполнения функции для определенных значений в кэше.
    Если функция вызывается с теми же значениями, то она возвращает сохраненный результат, не вычисляя его снова.
    """
    return fib_cache_helper(n, {})


@lru_cache(None)
def fib_lru_cache(n: int) -> int:
    """Рекурсивное вычисление числа Фибоначчи с кэшированием с помощью lru_cache. Сложность O(N)."""
    if n < 2:
        return n
    else:
        return fib_lru_cache(n - 1) + fib_lru_cache(n - 2)


def fib_dp(n: int) -> int:
    """
    Вычисление числа Фибоначчи методом динамического программирования. Сложность O(N).

    Динамическое программирование (DP) - это метод решения задачи путем разбиения ее на подзадачи,
    при этом ответ предыдущих подзадачи используется в следующей подзадаче.

    Подход с массивом называется динамическим программированием вперед. Он заключается в
    решении задачи от начала к концу, решая каждую подзадачу только один раз и сохраняя ее решение
    в массиве, чтобы использовать его в будущем. Однако, так же можно решать задачу от конца к началу,
    что называется динамическим программированием назад. В этом случае, начальные значения массива
    заполняются заранее, а затем массив заполняется от конца к началу.
    """
    a = [0] * (n + 1)
    a[1] = 1

    for i in range(2, n + 1):
        a[i] = a[i - 1] + a[i - 2]

    return a[n]
