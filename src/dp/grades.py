"""
https://contest.yandex.ru/contest/32588/problems/A/

Краткая легенда для задачи - Илья Сергеевич решил выписать подряд оценки студентов программной инженерии
и найти среди них образовательное комбо: такую подпоследовательность, оценки в которой не убывают
(что свидетельствует о повышении уровня студентов ПИ) и имеет наибольшую длину.

После утомительного перебора экспоненциального числа вариантов Илья Сергеевич поручил Вам решить и
автоматизировать эту задачу.

Формат ввода
Во входных данных две строки - в первой содержится количество оценок, выписанных Ильёй Сергеевичем.
Во второй - непосредственно сами оценки. Считаем, что каждая оценка это целое число от 0 до 10,
количество оценок не превышает 1000.

Формат вывода
В качестве ответа нужно также вывести две строки: в первой - лучшая найденная длина образовательного
комбо, вторая - содержит само комбо (числа разделены пробелами). Оформление заголовков можно найти в
примерах.

Пример
Ввод
5
0 5 1 6 2
Вывод
Best length = 3
Best combo is: 0 1 2
"""


def get_path(
    grade: list[int], length: list[int], prev: list[int]
) -> list[int]:
    """Восстановление пути. Сложность O(N)"""
    max_length_idx = 0
    for i, x in enumerate(length):
        if x >= length[max_length_idx]:
            max_length_idx = i

    path = []
    i = max_length_idx
    while i != -1:
        path.append(grade[i])
        i = prev[i]

    return path[::-1]


def grades(grade: list[int]) -> list[int]:
    """Решение задачи об оценках. Сложность O(N^2)"""
    n = len(grade)
    length = [1] * n
    """length[i] - длина максимальной неубывающей подпоследовательности, заканчивающейся на элементе i"""
    prev = [-1] * n
    """prev[i] - индекс предыдущего элемента в подпоследовательности, заканчивающейся на элементе i"""

    # Перебираем концы подпоследовательности
    for i in range(n):
        # Перебираем кандидатов на предыдущий элемент подпоследовательности и на основе
        # ответа в нём вычисляем ответ в i-м элементе
        for j in range(i):
            # Если условие неубывания выполняется и нашли более длинную подпоследовательность
            if grade[j] <= grade[i] and length[j] + 1 > length[i]:
                length[i] = length[j] + 1
                prev[i] = j

    return get_path(grade, length, prev)
