"""
https://kompege.ru/task, 2900

Набор данных представляет собой последовательность натуральных чисел. Необходимо выбрать такую подпоследовательность
подряд идущих чисел, чтобы их сумма была максимальной и делилась на D. В ответе укажите её сумму. Гарантируется, что
такая подпоследовательность существует.

Входные данные.
Даны два входных файла, каждый из которых содержит в первой строке делитель D (2 <= D <= 10000) и
количество чисел N (2 ≤ N ≤ 10^8). Каждая из следующих N строк содержит натуральное число, не превышающее 10000.

Пример входного файла:
1000 6
997
3
4
12
88
1900

В этом наборе можно выбрать последовательности 997+3 (сумма 1000) и 12+88+1900 (сумма 2000). 
Наибольшую сумму имеет вторая из этих последовательностей. Ответ: 2000

В ответе укажите два числа: сначала искомое значение для файла А, затем для файла B.
"""

INF = 10**20


def max_subsequence_sum_naive(d: int, a: list[int]) -> int:
    """Перебор всех подпоследовательностей. Сложность O(N^2)"""
    n = len(a)
    max_sum = -INF

    for i in range(n):
        s = 0
        for j in range(i, n):
            s += a[j]
            if s % d == 0:
                max_sum = max(max_sum, s)

    return max_sum


def max_subsequence_sum_ps(d: int, a: list[int]) -> int:
    """
    Префиксные суммы. Сложность O(N).
    Принцип работы на D = 100. Пусть есть последовательность: x0, x1, x2, x3, x4, x5, x6, ..., x_n.
    Префиксной суммой s_n будем называть сумму первых n чисел последовательности.

    Любая подпоследовательность - это разница двух префиксных сумм. Допустим, s2 = 122 и s6 = 2022. Чтобы получить
    сумму кратную 100, мы можем просто отрезать хвост из первых 3 эл-тов, поскольку мы знаем, что их сумма 122
    имеет такой же остаток от деления, что и наша 2022: 2022 - 122 = 1900. Для гарантии максимальности суммы будем
    вычитать минимальный хвостик.
    """
    n = len(a)
    tails = [INF] * d
    """tails[i] - минимальный хвостик с остатком i"""
    max_sum = -INF
    s = 0

    for i in range(n):
        s += a[i]

        if s % d == 0:
            max_sum = max(max_sum, s)

        # Из суммы вычитаем минимальный хвостик с тем же остатком
        prefix_sum = s - tails[s % d]

        # Обновляем ответ
        max_sum = max(max_sum, prefix_sum)

        # Обновляем минимальный хвостик
        tails[s % d] = min(tails[s % d], s)

    return max_sum
