# Задачи на базовые структуры данных

## A. Проверка расстановки скобок

| Поле      | Значение                                                     |
|-----------|--------------------------------------------------------------|
| Сложность | Легкая                                                       |
| Источник  | https://stepik.org/lesson/41234/step/1?unit=19818            |
| LeetCode  | https://leetcode.com/problems/valid-parentheses/description/ |

Вы разрабатываете текстовый редактор для программистов и хотите реализовать проверку корректности
расстановки скобок. В коде могут встречаться скобки []{}(). В случае, если скобки расставлены неправильно,
редактор должен также сообщить пользователю первое место, где обнаружена ошибка.

В первую очередь необходимо найти закрывающую скобку, для которой либо нет соответствующей открывающей
(например, скобка "]" в строке “]()”), либо же она закрывает не соответствующую ей открывающую скобку
(пример: "()[}"). Если таких ошибок нет, необходимо найти первую открывающую скобку,
для которой нет соответствующей закрывающей (пример: скобка "(" в строке “{}([]”).

Помимо скобок, исходный код может содержать символы латинского алфавита, цифры и знаки препинания.

Формат входа. Строка s[1...n], состоящая из заглавных и прописных букв латинского алфавита, цифр,
знаков препинания и скобок из множества []{}().

Формат выхода. Если скобки в s расставлены правильно, выведите
строку “Success". В противном случае выведите индекс (используя индексацию с единицы) первой закрывающей скобки, для
которой нет соответствующей открывающей. Если такой нет,
выведите индекс первой открывающей скобки, для которой нет
соответствующей закрывающей.

Пример 1.
Вход:

```
{[()]}
```

Выход:

```
Success
```

Пример 2.
Вход:

```
{[}
```

Выход:

```
3
```

## B. Среднее время ожидания клиента

| Поле      | Значение |
|-----------|----------|
| Сложность | Средняя  |
| Источник  | ChatGPT  |

В банке работает `N` окон для обслуживания клиентов. Определить,
сколько времени в среднем придется
ждать клиенту перед началом обслуживания.

Формат ввода.
В первой строке вводится число `N` - количество окон (1 ≤ N ≤ 1000) и число `M` - количество клиентов (1 ≤ M ≤ 1000).
Далее вводится M строк, в каждой из которых содержится два числа: время прихода клиента и время обслуживания клиента.

Формат вывода.
Выведите одно число - среднее время ожидания клиента перед началом обслуживания с точностью до 6 знаков после запятой.

Пример 1
Ввод

```
2 3
1 10
2 5
3 7
```

Вывод

```
1.333333
```

Пример 2
Ввод

```
1 3
1 1
2 1
3 1
```

Вывод

```
0
```

## C. Обработка сетевых пакетов

| Поле      | Значение                                          |
|-----------|---------------------------------------------------|
| Сложность | Средняя                                           |
| Источник  | https://stepik.org/lesson/41234/step/3?unit=19818 |

Ваша цель — реализовать симулятор обработки сетевых пакетов. Для i-го пакета известно время его
поступления arrival[i], а также время duration[i], необходимое на его обработку. В вашем распоряжении
имеется один процессор, который обрабатывает пакеты в порядке их поступления. Если процессор начинает
обрабатывать пакет i (что занимает время duration[i]), он не прерывается и не останавливается до тех пор,
пока не обработает пакет. У компьютера, обрабатывающего пакеты, имеется сетевой буфер
размера size. До начала обработки пакеты хранятся в буфере. Если буфер полностью заполнен в момент поступления
пакета (есть size пакетов, поступивших ранее, которые до сих пор не обработаны), этот
пакет отбрасывается и уже не будет обработан. Если несколько пакетов поступает в одно и то же время,
они все будут сперва сохранены в буфер (несколько последних из них могут быть отброшены, если буфер заполнится).

Компьютер обрабатывает пакеты в порядке их поступления. Он начинает обрабатывать следующий пакет из буфера
сразу после того, как обработает текущий пакет. Компьютер может простаивать, если все пакеты уже обработаны
и в буфере нет пакетов. Пакет освобождает место в буфере сразу же, как компьютер заканчивает его обработку.

Формат входа. Первая строка входа содержит размер буфера size и число пакетов n. Каждая из следующих n строк
содержит два числа: время arrival[i] прибытия i-го пакета и время duration[i], необходимое на его обработку.
Гарантируется, что arrival[1] ≤ arrival[2] ≤ · · · ≤ arrival[n]. При этом может оказаться, что arrival[i − 1]
= arrival[i]. В таком случае считаем, что пакет i − 1 поступил раньше пакета i.

Формат выхода. Для каждого из n пакетов выведите время, когда
процессор начал его обрабатывать, или −1, если пакет был отброшен.

Пример.
Вход:

```
1 8
0 0
0 0
0 0
1 1
1 0
1 0
1 2
1 3
```

Выход:

```
0 0 0 1 2 -1 -1 -1
```

## D. Стек максимума

| Поле      | Значение                                                           |
|-----------|--------------------------------------------------------------------|
| Сложность | Сложная                                                            |
| Источник  | https://stepik.org/lesson/41234/step/4?unit=19818                  |
| LeetCode  | https://leetcode.com/problems/max-stack/description/               |
| Похожая   | https://leetcode.com/problems/maximum-frequency-stack/description/ |

Стек — абстрактная структура данных, поддерживающая операции push и pop. Несложно реализовать стек так,
чтобы обе эти операции работали за константное время. В данной задаче ваша цель — расширить интерфейс стека так,
чтобы он дополнительно поддерживал операцию max и при этом чтобы время работы всех операций по-прежнему было
константным.

Формат входа. Первая строка содержит число запросов q. Каждая из
последующих q строк задаёт запрос в одном из следующих форматов: push v, pop, or max.

Формат выхода. Для каждого запроса max выведите (в отдельной
строке) текущий максимум на стеке.

Пример
Вход:

```
7
push 2
push 1
max
pop
max
push 3
max
```

Выход:

```
2
2
3
```

## E. Максимальное скользящее окно

| Поле      | Значение                                                          |
|-----------|-------------------------------------------------------------------|
| Сложность | Сложная                                                           |
| Источник  | https://stepik.org/lesson/41234/step/5?unit=19818                 |
| LeetCode  | https://leetcode.com/problems/sliding-window-maximum/description/ |
| Похожая   | https://leetcode.com/problems/sliding-window-median/description/  |

Найти максимум в каждом окне размера m данного массива чисел A[1...n].

Формат входа. Первая строка входа содержит число n, вторая — массив A[1...n],
третья — число m.

Формат выхода. Максимум подмассива A[i...i + m − 1] для всех 1 ≤ i ≤ n − m + 1.

Пример.
Вход:

```
8
2 7 3 1 5 2 6 2
4
```

Выход:

```
7 7 5 6 6
```

## F. Калькулятор

| Поле      | Значение                                                                    |
|-----------|-----------------------------------------------------------------------------|
| Сложность | Средняя                                                                     |
| Источник  | https://contest.yandex.ru/contest/31463/problems/?nc=cwKgF8vK               |
| Похожие   | https://leetcode.com/problems/evaluate-reverse-polish-notation/description/ |

Реализовать алгоритм разбора арифметического выражения. Допустимые операции в выражении: "+", "-", "*", "/",
числовые литералы, круглые скобки для задания приоритетности.

Формат ввода.
В качестве входа для алгоритма задана единственная строка - записанное арифметическое выражение.

Формат вывода.
Результатом работы алгоритма является вычисленное значение входного выражения.
Помимо результата необходимо вывести запись исходного выражения в постфиксной записи (обратной польской записи).

Пример.

Ввод:

```
(1+2)*4+3
```

Вывод:

```
1 2 + 4 * 3 +
15
```
