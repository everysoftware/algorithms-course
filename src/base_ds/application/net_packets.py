"""
https://stepik.org/lesson/41234/step/3?unit=19818

Ваша цель — реализовать симулятор обработки сетевых пакетов. Для i-го пакета известно время его
поступления arrival[i], а также время duration[i], необходимое на его обработку. В вашем распоряжении
имеется один процессор, который обрабатывает пакеты в порядке их поступления. Если процессор начинает
обрабатывать пакет i (что занимает время duration[i]), он не прерывается и не останавливается до тех пор,
пока не обработает пакет. У компьютера, обрабатывающего пакеты, имеется сетевой буфер
размера size. До начала обработки пакеты хранятся в буфере. Если буфер полностью заполнен в момент поступления
 пакета (есть size пакетов, поступивших ранее, которые до сих пор не обработаны), этот
пакет отбрасывается и уже не будет обработан. Если несколько пакетов поступает в одно и то же время,
они все будут сперва сохранены в буфер (несколько последних из них могут быть отброшены, если буфер заполнится).

Компьютер обрабатывает пакеты в порядке их поступления. Он начинает обрабатывать следующий пакет из буфера
сразу после того, как обработает текущий пакет. Компьютер может простаивать, если все пакеты уже обработаны
и в буфере нет пакетов. Пакет освобождает место в буфере сразу же, как компьютер заканчивает его обработку.

Формат входа. Первая строка входа содержит размер буфера size и число пакетов n. Каждая из следующих n строк
содержит два числа: время arrival[i] прибытия i-го пакета и время duration[i], необходимое на его обработку.
Гарантируется, что arrival[1] ≤ arrival[2] ≤ · · · ≤ arrival[n]. При этом может оказаться, что arrival[i − 1]
 = arrival[i]. В таком случае считаем, что пакет i − 1 поступил раньше пакета i.

Формат выхода. Для каждого из n пакетов выведите время, когда
процессор начал его обрабатывать, или −1, если пакет был отброшен.
"""

from collections import deque


def net_packets(size: int, packets: list[tuple[int, int]]) -> list[int]:
    """Решение задачи о симуляторе обработки сетевых пакетов. Сложность O(N)"""
    queue = deque()
    start_times = []

    for i, (arrival, duration) in enumerate(packets):
        # удаляем из очереди пакеты, которые уже обработаны
        while queue and queue[0] <= arrival:
            queue.popleft()

        if len(queue) == size:
            # если буфер полон, то пакет отбрасывается
            start_times.append(-1)
        else:
            # если буфер не полон, то пакет добавляется в очередь
            start_time = max(queue[-1] if queue else arrival, arrival)
            start_times.append(start_time)
            queue.append(start_time + duration)

    return start_times
