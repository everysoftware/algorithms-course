"""Порядковая статистика в массиве"""

from sortings.implementation import partition2

"""
Алгоритм quick_select использует метод быстрой сортировки для поиска k-й порядковой статистики в массиве.

Средняя временная сложность этого алгоритма составляет O(N), где N
 - это размер массива. Это потому, что каждый рекурсивный вызов обрабатывает массив меньшего размера.

Худшая временная сложность этого алгоритма составляет O(N^2). Это происходит в случае, когда входной массив уже
 отсортирован или обратно отсортирован. В этом случае каждый рекурсивный вызов обрабатывает массив, размер 
 которого меньше всего на один элемент.

Обратите внимание, что эти сложности могут быть улучшены до гарантированного O(N)
, если использовать “медиану медиан” в качестве опорного элемента, но это усложнит алгоритм.
"""


def quick_select(a: list[int], k: int) -> int:
    """
    Поиск k-й порядковой статистики в массиве.
    Сложность в среднем O(N), в худшем O(N^2).
    """
    if len(a) == 1:
        return a[0]

    # Переводим k в индекс массива
    k -= 1
    left = 0
    right = len(a) - 1
    while True:
        pivot_index = partition2(a, left, right)

        if k == pivot_index:
            return a[k]
        elif k < pivot_index:
            right = pivot_index - 1
        else:
            left = pivot_index + 1
