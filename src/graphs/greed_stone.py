"""
https://stepik.org/lesson/287380/step/1

В одной из мультивселенных могущественный титан Фанос собрал все камни конечности, победил храбрую команду
Блюстителей и поверг мир во тьму. Путешествуя по благодарному миру, Фанос забрел в портовый город у границы
с одной из людских колоний, называемой Р. Местные жители поведали герою легенду о самом большом богатстве
во вселенной – седьмом камне конечности, называемом камень жадности. По слухам, камень открывался только
тому, кто посетит все поселения Р, побывав в каждом ровно один раз (кроме того, в котором начинается
путешествие - в него нужно вернуться) и заплатив при этом самую низкую цену (да, путешествия по Р тоже
имеют свою цену).

Фанос узнал, что на территории Р работает только один из камней конечности - камень времени. И работает
он специфическим образом – переносит своего владельца в последний момент времени, когда обладатель находился
вне территории Р. Более того, энергия камня жадности настолько сильна, что как только Фанос попадает в поселения
Р, каждое свое перемещение между поселениями он делает максимально дешевым из возможных. Однако, находясь
вне Р, Фанос все еще может использовать камень пространства, чтобы мгновенно очутиться в любом из поселений.

После столь длинной истории наша задача проста – вычислить самый дешевый путь между поселениями Р,
который удалось найти Фаносу.

Входные данные: Входные данные содержат общее количество поселений n и стоимость путешествия между любой
парой поселений в виде матрицы. Поселения нумеруются от 0 до n-1.

Результат: В качестве результата необходимо вывести самый короткий путь между поселениями, который удалось
найти Фаносу, а также его стоимость. Если пути не существует, вывести "Lost".

Пример:
Ввод:
4
0 1 2 3
4 0 5 6
7 8 0 9
10 11 12 0
Вывод:
25
0 1 2 3 0
"""

INF = 10**20


def greed_stone(matrix: list[list[int]]) -> tuple[int, list[int]] | None:
    """Решает задачу коммивояжера с помощью жадного алгоритма. Сложность алгоритма O(N^3)."""
    n = len(matrix)

    # Преобразуем матрицу стоимости так, чтобы стоимость перемещения из города в самого себя была равна
    # бесконечности. Это помогает нам убедиться, что мы не останемся в том же городе при выборе следующего
    # города для посещения.
    matrix = [[(x if x != 0 else INF) for x in costs] for costs in matrix]

    # Инициализируем минимальную стоимость и путь.
    min_cost, min_path = INF, []

    # Для каждого города мы пытаемся найти путь, начинающийся в этом городе, который посещает все города
    # и возвращает нас обратно в начальный город.
    for start_city in range(n):
        # Инициализируем список посещенных городов и путь.
        visited = [False] * n
        path, cost = [start_city], 0

        # Инициализируем текущий город.
        city = start_city
        for _ in range(n - 1):
            visited[city] = True

            # Выбираем следующий город, который еще не был посещен и имеет минимальную стоимость
            # перемещения из текущего города.
            next_city, score = min(
                ((c, matrix[city][c]) for c in range(n) if not visited[c]),
                key=lambda x: x[1],
            )

            # Добавляем выбранный город в путь и увеличиваем общую стоимость на стоимость перемещения до
            # выбранного города.
            path.append(next_city)
            cost += score

            # Обновляем текущий город.
            city = next_city

        # После посещения всех городов мы возвращаемся в начальный город.
        # Увеличиваем общую стоимость на стоимость перемещения обратно в начальный город.
        cost += matrix[city][start_city]
        path.append(start_city)

        # Если общая стоимость пути меньше минимальной стоимости пути, который мы нашли до этого,
        # обновляем минимальную стоимость и путь.
        if cost < min_cost:
            min_cost = cost
            min_path = path

    if min_cost == INF:
        return None

    return min_cost, min_path
