# O(n^2)
def shortest_naive(s: str) -> str:
    r = s[::-1]
    # Проверяем префиксы перевернутой строки
    for i in range(len(r) + 1):
        # Если префикс совпадает с суффиксом
        if s.startswith(r[i:]):
            # Добавляем оставшиеся символы в начало строки.
            return r[:i] + s
    return r + s


# O(n)
def shortest_kmp(s: str) -> str:
    r = s[::-1]
    # Вычисляем префикс-функцию для строки s и ее обращения.
    pi = get_pi(s, r)
    # Длина совпадающей части.
    count = pi[-1]
    # Несовпадающая часть строки.
    diff = r[: len(r) - count]
    # Добавляем несовпадающую часть в начало.
    return diff + s


def get_pi(text: str, pattern: str) -> list[int]:
    s = text + "#" + pattern
    n = len(s)
    # Пусть pi[i] - длина наибольшего префикса-суффикса на подстроке s[:i].
    # Не будем использовать префиксы и суффиксы, которые являются самим словом.
    pi = [0] * n
    # Рассматриваем префиксы-суффиксы в текущем окне.
    for high in range(1, n):
        # Ищем, какой префикс-суффикс можно расширить.
        # Начинаем с предыдущего префикса-суффикса.
        low = pi[high - 1]
        # Пока не нашли подходящий, берем предыдущий префикс-суффикс.
        while low > 0 and s[low] != s[high]:
            # Переходим к следующему префиксу.
            low = pi[low - 1]
        # Если нашли, то расширяем префикс-суффикс текущим символом.
        if s[low] == s[high]:
            low += 1
        # Сохраняем длину префикса-суффикса.
        pi[high] = low
    return pi
