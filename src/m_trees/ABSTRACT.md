# Деревья

## Деревья

**Дерево** - это иерархическая структура данных, состоящая из вершин и ребер, которые их соединяют.

Деревья подобны графам, однако, между ними есть несколько ключевых отличий:

* Иерархия. Деревья имеют строгую иерархию (корень, ветви, листья). Графы не имеют явной иерархии.
* Связи. В деревьях каждая вершина (кроме корня) имеет ровно одного родителя. В графах вершина может быть связана с
  любым количеством других вершин.
* Циклы. Деревья не содержат циклов. Графы могут содержать циклы.

Термины, которые используются при работе с деревьями:

| Понятие         | Описание                                               |
|-----------------|--------------------------------------------------------|
| Вершина         | Элемент дерева, который содержит данные.               |
| Ребро           | Связь между двумя вершинами.                           |
| Корень          | Вершина, которая не имеет родителя.                    |
| Листья          | Вершины, которые не имеют дочерних вершин.             |
| Путь            | Последовательность вершин, соединенных ребрами.        |
| Высота вершины  | Расстояние от корня до вершины. Уровень корня равен 0. |
| Высота дерева   | Длина самого длинного пути от корня до листа.          |
| Степень вершины | Количество дочерних вершин.                            |
| Поддерево       | Часть дерева, состоящая из вершины и всех ее потомков. |

Деревья широко используются в области искусственного интеллекта и в сложных алгоритмах, выступая в качестве эффективного
хранилища информации при решении задач.

## Представления дерева

Деревья в общем виде могут быть представлены различными способами:

* **Список смежности** - каждая вершина хранит список своих дочерних вершин.
* **Структуры данных** - каждая вершина представляется как объект, содержащий данные и ссылки на дочерние вершины.

Возьмем дерево:

```text
    A
   / \
  B   C
 / \   \
D   E   F
```

Это дерево можно представить в виде списка смежности:

```text
A : B, C
B : D, E
C : F
D :
E :
F :
```

Или в виде структуры данных, где каждая вершина содержит данные и ссылки на дочерние вершины:

```python
from __future__ import annotations

from dataclasses import dataclass, field


@dataclass
class Node:
    key: str
    children: list[Node] = field(default_factory=list)

    def add_child(self, child_node: Node) -> None:
        self.children.append(child_node)


# Пример дерева
root = Node('A')
root.add_child(Node('B'))
root.add_child(Node('C'))
root.children[0].add_child(Node('D'))
root.children[0].add_child(Node('E'))
root.children[1].add_child(Node('F'))
```

## Двоичные деревья

**Двоичное дерево** - это дерево, в котором каждая вершина имеет не более двух дочерних вершин.

Двоичные деревья могут быть представлены различными способами:

* **Список смежности** - каждая вершина хранит список своих дочерних вершин.
* **Массивы** - дерево представляется в виде массива, где для каждой вершины i:
    * Левый дочерний элемент находится по индексу $2*i + 1$
    * Правый дочерний элемент находится по индексу $2*i + 2$
* **Структуры данных** - каждая вершина представляется как объект, содержащий данные и ссылки на левую и правую дочерние
  вершины.

Возьмем такое двоичное дерево:

```text
    A
   / \
  B   C
 / \   \
D   E   F
```

Представим его в виде массива:

```text
[ A, B, C, D, E, None, F ]
```

А теперь в виде структуры данных, где каждая вершина содержит данные и ссылки на дочерние вершины:

```python
from __future__ import annotations

from dataclasses import dataclass


@dataclass
class Node:
    key: str
    left: Node | None = None
    right: Node | None = None


# Пример дерева
root = Node('A')
root.left = Node('B')
root.right = Node('C')
root.left.left = Node('D')
root.left.right = Node('E')
root.right.right = Node('F')
```

## Обход в глубину

**DFS** (Depth-First Search) - обход в глубину - это алгоритм обхода графа или дерева, который начинается с начальной
вершины и идет вглубь каждой ветви, пока не достигнет конечной вершины.

Сложность DFS: O(N), N = V + E, где V - количество вершин, E - количество ребер.

Пример.

Возьмем дерево:

```text
    A
   / \
  B   C
 / \   \
D   E   F
```

Обход в глубину начинается с вершины A и проходит по всем вершинам графа:

```text
A -> B -> D -> E -> C -> F
```

Для двоичного дерева выделяют три основных типа обхода:

* **Прямой обход** (Pre-order): сначала посещается корень, затем левое поддерево, затем правое поддерево.
* **Симметричный обход** (In-order): сначала посещается левое поддерево, затем корень, затем правое поддерево.
* **Обратный обход** (Post-order): сначала посещается левое поддерево, затем правое поддерево, затем корень.
