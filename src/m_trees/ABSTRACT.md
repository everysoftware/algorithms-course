# Деревья

## Деревья

**Дерево** - это иерархическая структура данных, состоящая из вершин и ребер, которые их соединяют.

Деревья подобны графам, однако, между ними есть несколько ключевых отличий:

* Иерархия. Деревья имеют строгую иерархию (корень, ветви, листья). Графы не имеют явной иерархии.
* Связи. В деревьях каждая вершина (кроме корня) имеет ровно одного родителя. В графах вершина может быть связана с
  любым количеством других вершин.
* Циклы. Деревья не содержат циклов. Графы могут содержать циклы.

Термины, которые используются при работе с деревьями:

| Понятие         | Описание                                               |
|-----------------|--------------------------------------------------------|
| Вершина         | Элемент дерева, который содержит данные.               |
| Ребро           | Связь между двумя вершинами.                           |
| Корень          | Вершина, которая не имеет родителя.                    |
| Листья          | Вершины, которые не имеют дочерних вершин.             |
| Путь            | Последовательность вершин, соединенных ребрами.        |
| Высота вершины  | Расстояние от корня до вершины. Уровень корня равен 0. |
| Высота дерева   | Длина самого длинного пути от корня до листа.          |
| Степень вершины | Количество дочерних вершин.                            |
| Поддерево       | Часть дерева, состоящая из вершины и всех ее потомков. |

Деревья широко используются в области искусственного интеллекта и в сложных алгоритмах, выступая в качестве эффективного
хранилища информации при решении задач.

## Представления дерева

Деревья в общем виде могут быть представлены различными способами:

* **Список смежности** - каждая вершина хранит список своих дочерних вершин.
* **Структуры данных** - каждая вершина представляется как объект, содержащий данные и ссылки на дочерние вершины.

Возьмем дерево:

```text
    A
   / \
  B   C
 / \   \
D   E   F
```

Это дерево можно представить в виде списка смежности:

```text
A : B, C
B : D, E
C : F
D :
E :
F :
```

Или в виде структуры данных, где каждая вершина содержит данные и ссылки на дочерние вершины:

```python
from __future__ import annotations

from dataclasses import dataclass, field


@dataclass
class Node:
    key: str
    children: list[Node] = field(default_factory=list)

    def add_child(self, child_node: Node) -> None:
        self.children.append(child_node)


# Пример дерева
root = Node('A')
root.add_child(Node('B'))
root.add_child(Node('C'))
root.children[0].add_child(Node('D'))
root.children[0].add_child(Node('E'))
root.children[1].add_child(Node('F'))
```

## Двоичные деревья

**Двоичное дерево** - это дерево, в котором каждая вершина имеет не более двух дочерних вершин.

Двоичные деревья могут быть представлены различными способами:

* **Список смежности** - каждая вершина хранит список своих дочерних вершин.
* **Массивы** - дерево представляется в виде массива, где для каждой вершины i:
    * Левый дочерний элемент находится по индексу $2*i + 1$
    * Правый дочерний элемент находится по индексу $2*i + 2$
* **Структуры данных** - каждая вершина представляется как объект, содержащий данные и ссылки на левую и правую дочерние
  вершины.

Возьмем такое двоичное дерево:

```text
    A
   / \
  B   C
 / \   \
D   E   F
```

Представим его в виде массива:

```text
[ A, B, C, D, E, None, F ]
```

А теперь в виде структуры данных, где каждая вершина содержит данные и ссылки на дочерние вершины:

```python
from __future__ import annotations

from dataclasses import dataclass


@dataclass
class Node:
    key: str
    left: Node | None = None
    right: Node | None = None


# Пример дерева
root = Node('A')
root.left = Node('B')
root.right = Node('C')
root.left.left = Node('D')
root.left.right = Node('E')
root.right.right = Node('F')
```

## Обход в глубину

**DFS** (Depth-First Search) - обход в глубину - это алгоритм обхода графа или дерева, который начинается с начальной
вершины и идет вглубь каждой ветви, пока не достигнет конечной вершины.

Сложность DFS: O(N), N = V + E, где V - количество вершин, E - количество ребер.

Пример.

Возьмем дерево:

```text
    A
   / \
  B   C
 / \   \
D   E   F
```

Обход в глубину начинается с вершины A и проходит по всем вершинам графа:

```text
A -> B -> D -> E -> C -> F
```

Для двоичного дерева выделяют три основных типа обхода:

* **Прямой обход** (Pre-order): сначала посещается корень, затем левое поддерево, затем правое поддерево.
* **Симметричный обход** (In-order): сначала посещается левое поддерево, затем корень, затем правое поддерево.
* **Обратный обход** (Post-order): сначала посещается левое поддерево, затем правое поддерево, затем корень.

## Обход в ширину

**BFS** (Breadth-First Search) - обход в ширину - это алгоритм обхода графа или дерева, который начинается с
начальной вершины и проходит по всем вершинам на текущем уровне, прежде чем перейти к следующему уровню.
Сложность BFS: O(N), N = V + E, где V - количество вершин, E - количество ребер.

Пример.
Возьмем дерево:

```text
    A
   / \
  B   C
 / \   \
D   E   F
```

Обход в ширину начинается с вершины A и проходит по всем вершинам на текущем уровне:

```text
A -> B -> C -> D -> E -> F
```

По-другому обход в ширину можно представить в виде уровней:

```text
Уровень 0: A
Уровень 1: B, C
Уровень 2: D, E, F
```

Поэтому обход в ширину также называют **уровневым обходом** (Level-order).

## Деревья поиска

**Дерево поиска** - это двоичное дерево, в котором для каждой вершины выполняется следующее условие:

* Все ключи в левом поддереве меньше ключа вершины.
* Все ключи в правом поддереве больше ключа вершины.
* Левое и правое поддеревья также являются деревьями поиска.

Деревья поиска позволяют эффективно выполнять операции поиска, вставки и удаления элементов.

Сложность операций в дереве поиска: O(log N) в среднем случае, O(N) в худшем случае (если дерево вырождено в список).

Пример.

```text
    4
   / \
  2   6
 / \   \
1   3   5
```

## Сбалансированные деревья

**Сбалансированное дерево** - это дерево, в котором высота левого и правого поддеревьев для каждой вершины отличается не
более чем на 1.

Сбалансированные деревья позволяют поддерживать операции поиска, вставки и удаления элементов с логарифмической
сложностью O(log N) в худшем случае.

Пример сбалансированного дерева:

```text
    4
   / \
  2   6
 / \   \
1   3   5
```

Это дерево сбалансировано, потому что высота левого и правого поддеревьев для каждой вершины отличается
не более чем на 1.

Существует несколько типов сбалансированных деревьев:

* **AVL-деревья** - это сбалансированные двоичные деревья поиска, в которых для каждой вершины высота левого и правого
  поддеревьев отличается не более чем на 1.
* **Красно-черные деревья** - это сбалансированные двоичные деревья поиска, в которых каждая вершина имеет цвет (красный
  или черный) и выполняются определенные правила для поддержания баланса.
* **Splay-деревья** - это сбалансированные двоичные деревья поиска, которые автоматически перемещают часто
  используемые элементы ближе к корню дерева, что позволяет ускорить доступ к ним.
* **B-деревья** - это сбалансированные деревья поиска, которые используются в базах данных и файловых системах для
  эффективного хранения и поиска больших объемов данных. Они позволяют хранить множество ключей в одной вершине и
  обеспечивают логарифмическую сложность операций поиска, вставки и удаления.
