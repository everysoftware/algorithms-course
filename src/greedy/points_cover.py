"""
Даны точки на прямой. Необходимо покрыть их минимальным числом отрезков длины 1.

Формат ввода. В первой строке задано число n точек на прямой. Во второй строке заданы n целых чисел
x_i — координаты точек.

Формат вывода. Минимальное число m отрезков длины 1, необходимых для покрытия всех точек.
"""


def points_cover(points: list[float]) -> list[tuple[float, float]]:
    """
    Минимальное покрытие точек единичными отрезками. Сложность O(N^2).
    Принцип работы:
    1. Находим минимальную точку.
    2. Добавляем отрезок, начинающийся в этой точке.
    3. Удаляем все точки, которые покрываются этим отрезком.
    4. Повторяем шаги 1-3, пока не покроем все точки.
    """
    cover = []

    while points:
        x_m = min(points)
        cover.append((x_m, x_m + 1))
        points = [x for x in points if x > x_m + 1]

    return cover


def points_cover_enhanced(points: list[float]) -> list[tuple[float, float]]:
    """
    Минимальное покрытие точек единичными отрезками. Сложность O(NlogN).
    Принцип работы:
    1. Сортируем точки по возрастанию.
    2. Пока есть точки, добавляем отрезок, начинающийся в минимальной точке.
    3. Пропускаем все точки, которые покрываются текущим отрезком.
    4. Повторяем шаги 2-3, пока не покроем все точки.
    """
    n = len(points)
    points.sort()
    cover = []

    i = 0
    while i < n:
        # Добавляем отрезок, начинающийся в текущей точке
        segment = (points[i], points[i] + 1)
        cover.append(segment)
        i += 1

        # Пропускаем все точки, которые покрываются текущим отрезком
        while i < n and points[i] <= segment[1]:
            i += 1

    return cover
