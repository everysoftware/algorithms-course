"""
https://stepik.org/lesson/287380/step/1

В одной из мультивселенных могущественный титан Фанос собрал все камни конечности, победил храбрую команду
Блюстителей и поверг мир во тьму. Путешествуя по благодарному миру, Фанос забрел в портовый город у границы
с одной из людских колоний, называемой Р. Местные жители поведали герою легенду о самом большом богатстве
во вселенной – седьмом камне конечности, называемом камень жадности. По слухам, камень открывался только
тому, кто посетит все поселения Р, побывав в каждом ровно один раз (кроме того, в котором начинается
путешествие - в него нужно вернуться) и заплатив при этом самую низкую цену (да, путешествия по Р тоже
имеют свою цену).

Фанос узнал, что на территории Р работает только один из камней конечности - камень времени. И работает
он специфическим образом – переносит своего владельца в последний момент времени, когда обладатель находился
вне территории Р. Более того, энергия камня жадности настолько сильна, что как только Фанос попадает в поселения
Р, каждое свое перемещение между поселениями он делает максимально дешевым из возможных. Однако, находясь
вне Р, Фанос все еще может использовать камень пространства, чтобы мгновенно очутиться в любом из поселений.

После столь длинной истории наша задача проста – вычислить самый дешевый путь между поселениями Р,
который удалось найти Фаносу.

Входные данные: Входные данные содержат общее количество поселений n и стоимость путешествия между любой
парой поселений в виде матрицы. Поселения нумеруются от 0 до n-1.

Результат: В качестве результата необходимо вывести самый короткий путь между поселениями, который удалось
найти Фаносу, а также его стоимость. Если пути не существует, вывести "Lost".
"""

"""
АЛЬТЕНАТИВНАЯ ФОРМУЛИРОВКА.

Изначально условие этой задачи было приурочено к выходу фильма "Мстители: Война бесконечности" и сочетало 
элементы истории о супергероях земли и небольшую метафору на российскую действительность тех лет.

Спустя много лет Илья Сергеевич решился сделать условие более точным :)

В данной задаче имеется набор координат на плоскости, которые соответствуют расположению некоторых городов.
Коммивояжер хочет начать свое путешествие в некотором городе, проехать по всем существующем городам 
(побывав в каждом за исключением первого лишь однажды) и вернуться в стартовый город.

Как и любой торговец, наш коммивояжер очень любит самые выгодные сделки и каждый раз старается поехать в 
тот город, цена путешествия в который из текущего минимальна. Также он хочет из всех возможных для него 
вариантов маршрутов выбрать самый дешевый.

Наша задача помочь коммивояжеру выбрать место для начала путешествия и посчитать итоговую стоимость его 
маршрута.

Формат ввода
Входные данные содержат общее количество городов n и стоимость путешествия между любой парой городов в виде
матрицы. Города нумеруются от 0 до n-1.

Формат вывода
В качестве результата необходимо вывести самый дешевый путь между городами, который удалось найти 
коммивояжеру и стоимость этого пути. Если пути не существует, вывести "Lost".
"""


def greed_stone(matrix: list[list[int]]) -> tuple[int, list[int]] | None:
    """Решает задачу коммивояжера с помощью жадного алгоритма. Сложность алгоритма O(N^2)."""
    n = len(matrix)

    # Преобразуем матрицу стоимости так, чтобы стоимость перемещения из города в самого себя была равна
    # бесконечности. Это помогает нам убедиться, что мы не останемся в том же городе при выборе следующего
    # города для посещения.
    matrix = [[(x if x != 0 else float("inf")) for x in costs] for costs in matrix]

    # Инициализируем минимальную стоимость и путь.
    min_cost, min_path = float("inf"), []

    # Для каждого города мы пытаемся найти путь, начинающийся в этом городе, который посещает все города
    # и возвращает нас обратно в начальный город.
    for start_city in range(n):
        # Инициализируем список посещенных городов и путь.
        visited = [False] * n
        path, cost = [start_city], 0

        # Инициализируем текущий город.
        city = start_city
        for _ in range(n - 1):
            visited[city] = True

            # Выбираем следующий город, который еще не был посещен и имеет минимальную стоимость
            # перемещения из текущего города.
            next_city, score = min(
                ((c, matrix[city][c]) for c in range(n) if not visited[c]),
                key=lambda x: x[1],
            )

            # Добавляем выбранный город в путь и увеличиваем общую стоимость на стоимость перемещения до
            # выбранного города.
            path.append(next_city)
            cost += score

            # Обновляем текущий город.
            city = next_city

        # После посещения всех городов мы возвращаемся в начальный город.
        # Увеличиваем общую стоимость на стоимость перемещения обратно в начальный город.
        cost += matrix[city][start_city]
        path.append(start_city)

        # Если общая стоимость пути меньше минимальной стоимости пути, который мы нашли до этого,
        # обновляем минимальную стоимость и путь.
        if cost < min_cost:
            min_cost = cost
            min_path = path

    if min_cost == float("inf"):
        return None

    return min_cost, min_path
