import bisect


# O(n log n)
def lnis(a: list[int]) -> list[int]:
    n = len(a)
    # tail[i] - последний элемент ННП длины i
    tail: list[int] = []
    # Чтобы восстановить ННП, нам нужно знать индексы элементов, которые входят в ННП:
    # tail_idx[i] - индекс последнего элемента ННП длины i,
    # prev[i] - индекс предыдущего элемента ННП длины i
    tail_idx: list[int] = []
    prev = [-1] * n
    # Перебираем элементы
    for i, x in enumerate(a):
        # Если текущий элемент больше последнего элемента ННП, то он может её продолжить
        if not tail or x <= tail[-1]:
            # Запоминаем индекс предыдущего элемента ННП
            if tail_idx:
                prev[i] = tail_idx[-1]
            # Текущий элемент становится новым последним элементом ННП
            tail.append(x)
            tail_idx.append(i)
        # Если текущий элемент больше последнего элемента ННП, то он может её улучшить
        else:
            # Больший элемент должен быть вставлен в ННП, чтобы она была как можно длиннее.
            # Например, a = [0, 7, 1, 6, 2]. Когда мы встречаем 7, то 7 должен заменить 0, чтобы ННП была длиннее,
            # так как элементов меньших или равных 7 очевидно больше, чем элементов меньших или равных 0.
            # Используем bisect_right, поскольку хотим вставить элемент после всех элементов, равных ему, чтобы
            # подпоследовательность была как можно длиннее
            idx_to_insert = bisect.bisect_right(tail, -x, key=lambda y: -y)
            # Запоминаем индекс предыдущего элемента НВП
            if idx_to_insert > 0:
                prev[i] = tail_idx[idx_to_insert - 1]
            # Заменяем найденный элемент НВП на текущий элемент
            tail[idx_to_insert] = x
            tail_idx[idx_to_insert] = i
    return get_path(a, prev, tail_idx)


# O(n)
def get_path(a: list[int], prev: list[int], tail_idx: list[int]) -> list[int]:
    path = []
    # Индекс последнего элемента ННП
    t = tail_idx[-1]
    # Восстанавливаем ННП
    while t != -1:
        # Добавляем элемент в ННП
        path.append(a[t])
        # Переходим к предыдущему элементу ННП
        t = prev[t]
    # Возвращаем ННП в обратном порядке
    return path[::-1]
