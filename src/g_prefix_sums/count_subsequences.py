from collections import deque


# O(n^2)
def count_subsequences_naive(k: int, a: list[int]) -> int:
    n = len(a)
    count = 0
    for i in range(n):
        s = 0
        for j in range(i, n):
            s += a[j]
            if s % k == 0 and j - i + 1 >= 5:
                count += 1
    return count


# O(n)
def count_subsequences_ps(k: int, a: list[int]) -> int:
    n = len(a)
    # Число префиксных сумм с определенным остатком от деления на k будем хранить в массиве dp
    dp = [0] * k
    # Число подходящих подпоследовательностей
    count = 0
    # Текущая сумма
    s = 0
    # Считаем первые 4 префиксные суммы
    q: deque[int] = deque()
    for i in range(4):
        s += a[i]
        q.append(s)
    # Считаем ответ
    for i in range(4, n):
        # Добавляем элемент в сумму
        s += a[i]
        # Если сумма подходит сама по себе, увеличиваем счетчик на 1
        if s % k == 0:
            count += 1
        # Считаем число подходящих подпоследовательностей.
        # 1. Чтобы S стала кратна K, нужно отрубить от неё префикс с таким же остатком.
        # Например, если K = 3, S = 10, S % K = 1. Тогда из S надо выкинуть префикс с остатком 1.
        # 2. Следовательно, число подходящих подпоследовательностей возрастает на число префиксов с остатком S % K,
        # так как каждый из них можно отрубить от S.
        count += dp[s % k]
        # После обработки суммы, мы начинаем учитывать первую в очереди префиксную сумму. Удаляем её из очереди
        # и увеличиваем счетчик префиксных сумм с таким же остатком на 1.
        dp[q.popleft() % k] += 1
        # Кладем в очередь текущую сумму
        q.append(s)
    return count
