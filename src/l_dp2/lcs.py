# O(n * m)
def lcs_dp(a: str, b: str) -> int:
    n, m = len(a), len(b)
    # dp[i][j] - длина наибольшей общей подпоследовательности для a[:i] и b[:j]
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    for i in range(n + 1):
        for j in range(m + 1):
            # Если одна из строк пустая, то длина общей подпоследовательности равна 0
            if i == 0 or j == 0:
                dp[i][j] = 0
            # Если последние символы совпадают, то длина общей подпоследовательности увеличивается на 1
            elif a[i - 1] == b[j - 1]:
                dp[i][j] = 1 + dp[i - 1][j - 1]
            # Иначе берем максимум из двух вариантов:
            # 1. Уменьшаем строку A на 1
            # 2. Уменьшаем строку B на 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[n][m]


# O(2^(min(n, m)))
def lcs_rec(a: str, b: str) -> int:
    return _lcs_rec(a, b, len(a), len(b))


def _lcs_rec(a: str, b: str, n: int, m: int) -> int:
    # Если одна из строк пустая, то длина общей подпоследовательности равна 0
    if n == 0 or m == 0:
        return 0
    # Если последние символы совпадают, то уменьшаем обе строки на 1
    elif a[n - 1] == b[m - 1]:
        return 1 + _lcs_rec(a, b, n - 1, m - 1)
    # Иначе берем максимум из двух вариантов:
    # 1. Уменьшаем строку A на 1
    # 2. Уменьшаем строку B на 1
    else:
        return max(_lcs_rec(a, b, n - 1, m), _lcs_rec(a, b, n, m - 1))
