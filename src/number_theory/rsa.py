"""
https://contest.yandex.ru/contest/29847/problems/C/

В данной задаче необходимо реализовать шифрование входных данных с помощью алгоритма RSA (Rivest–Shamir–Adleman).

Формат ввода
В качестве входных данных подаётся две строки.
В первой строке через пробел заданы три числа - простые числа p и q, а также число e_start - начальное значение,
с которого алгоритм будет искать публичный ключ. Строка заканчивается символом переноса строки и возврата каретки.
Во второй строке задана последовательность символов для шифрования. Длина последовательности не превышает 6
символов. Допустимые символы - символы латинского алфавита в нижнем регистре.

Формат вывода
В качестве результата необходимо в формате лога (см. пример ниже) вывести следующие значения:
Первая строка - закрытый ключ (d, n)
Вторая строка - публичный ключ (e, n)
Третья строка - начальный набор байт через пробел
Четвертая строка - зашифрованный набор байт через пробел

Пример 1
Ввод
13 19 2
a
Вывод
Private: 173 247
Public: 5 247
Initial bytes: 97
Encrypted bytes: 184
Пример 2
Ввод
13 23 2
a
Вывод
Private: 53 299
Public: 5 299
Initial bytes: 97
Encrypted bytes: 158

"""

from math import gcd


def generate_keypair(p: int, q: int, e_start: int) -> tuple[tuple[int, int], tuple[int, int]]:
    """Генерация пары ключей (открытый, закрытый) для алгоритма RSA. Сложность: O(PQ)"""
    n = p * q
    phi = (p - 1) * (q - 1)

    # Создание открытого ключа
    e = e_start
    g = gcd(e, phi)

    while g != 1:
        e += 1
        g = gcd(e, phi)

    # Создание закрытого ключа
    d = pow(e, -1, phi)

    return (e, n), (d, n)


def to_bytes(n: int) -> list[int]:
    """Перевод числа в список байтов. Сложность: O(log(N))."""
    bytes_list = []

    while n != 0:
        bytes_list.append(n & 0xFF)  # n % 256
        n >>= 8  # n //= 256

    return bytes_list[::-1]


def encrypt(plaintext: str, public_key: tuple[int, int]) -> list[int]:
    """
    Шифрование данных с помощью открытого ключа.
    Сложность: O(S + logE), где S - длина строки, E - открытый ключ.
    """
    e, n = public_key
    data_bytes = plaintext.encode("utf-8")
    encrypted = pow(int.from_bytes(data_bytes), e, n)

    return to_bytes(encrypted)
