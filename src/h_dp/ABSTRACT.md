# Динамическое программирование

## Принцип динамического программирования

Чтобы понять, какую проблему решает динамическое программирование, рассмотрим классическую задачу.

> Числами Фибоначчи называется последовательность чисел, в которой первое и второе числа равны 1, а каждое число
> является суммой двух предыдущих.
> Дано натуральное число N. Вычислите N-е число Фибоначчи.

Наивное решение задачи, обычно представленное рекурсивным алгоритмом, может быть очень неэффективным, так как оно
может многократно решать одни и те же подзадачи:

```python
def fib_rec(n: int) -> int:
    if n < 2:
        return n
    else:
        return fib_rec(n - 1) + fib_rec(n - 2)
```

**Динамическое программирование** (ДП) - это метод решения задач путем разбиения их на более простые пересекающиеся
подзадачи. При этом, результаты подзадач сохраняются в таблице, чтобы избежать повторного решения одних и тех же
подзадач.

## Виды динамического программирования

**Рекурсия с мемоизацией** (ДП сверху-вниз) - это метод, при котором решение задачи начинается с самой большой подзадачи
и постепенно
уменьшается до самой маленькой. Этот метод использует рекурсию для решения подзадач. При этом, результаты
подзадач сохраняются в таблице, чтобы избежать повторного решения одних и тех же подзадач. По-другому этот метод
называют **кэшированием** или **ленивым вычислением**.

```python
cache = {}


def fib_cache(n: int) -> int:
    if n < 2:
        return n
    if n not in cache:
        cache[n] = fib_cache(n - 1) + fib_cache(n - 2)
    return cache[n]
```

В Python для реализации рекурсии с мемоизацией можно использовать декоратор `functools.lru_cache`:

```python
from functools import lru_cache


@lru_cache(None)
def fib_lru(n: int) -> int:
    if n < 2:
        return n
    else:
        return fib_lru(n - 1) + fib_lru(n - 2)
```

**Итеративный алгоритм** (ДП снизу-вверх) - это метод, при котором решение задачи начинается с самой
маленькой подзадачи и постепенно увеличивается до самой большой. Этот метод использует циклы для решения подзадач. При
этом, результаты подзадач сохраняются в таблице, чтобы избежать повторного решения одних и тех же подзадач. Обычно этот
метод и подразумевается под **динамическим программированием**.

```python
def fib_dp(n: int) -> int:
    a = [0] * (n + 1)
    a[1] = 1
    for i in range(2, n + 1):
        a[i] = a[i - 1] + a[i - 2]
    return a[n]
```

Сравнение рекурсии с мемоизацией и итеративного алгоритма:

| **Критерий**         | **Рекурсия с мемоизацией**                                                                                                   | **Итеративный алгоритм**                                                                                   |
|----------------------|------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|
| Простота реализации  | Реализация может быть проще и интуитивнее для задач, которые естественно описываются рекурсивно (например, числа Фибоначчи). | Реализация требует разработки явного цикла и хранения промежуточных данных, что иногда сложнее понять.     |
| Производительность   | Быстрее, чем чистая рекурсия, но возможны накладные расходы из-за вызовов функций и хранения кэша.                           | Обычно быстрее, так как нет накладных расходов на вызовы функций и используется линейный проход.           |
| Использование памяти | Может использовать больше памяти из-за стека вызовов и хранения таблицы мемоизации.                                          | Использует меньше памяти, так как обходится без стека вызовов и часто требует только несколько переменных. |
| Подход к задаче      | Подходит для задач, которые можно естественно разбить на подзадачи с перекрытием результатов.                                | Подходит для задач с естественным линейным или итеративным процессом вычислений.                           |
| Пример реализации    | Рекурсивный с сохранением результатов в таблице для предотвращения повторных вычислений.                                     | Использование цикла для пошагового вычисления результатов.                                                 |
| Требования к кэшу    | Нужен кэш для хранения уже вычисленных результатов (в виде массива, словаря или другого типа структуры).                     | Обычно не требует кэша, кроме случаев, когда нужно хранить все промежуточные результаты.                   |
| Сложность кода       | Код может быть компактным, но сложным для отладки из-за вложенных вызовов функций.                                           | Код более последовательный, отладка и понимание выполняются проще.                                         |
| Примеры задач        | Числа Фибоначчи, задачи на разбиение (например, разбиение суммы на монеты).                                                  | Поиск наибольшей общей подпоследовательности, вычисление факториала, итеративный подсчет Фибоначчи.        |
| Ограничения          | Может привести к переполнению стека вызовов при больших входных данных.                                                      | Не подвержен переполнению стека, но может потребовать больше времени для разработки.                       |

## Оптимизация памяти

При решении задач методом динамического программирования, часто можно оптимизировать использование памяти. Например,
можно использовать только две переменные для хранения последних двух значений, а не массив для хранения всех
промежуточных значений.

```python
def fib_two_last(n: int) -> int:
    fib1 = 0
    fib2 = 1
    for i in range(2, n + 1):
        fib1, fib2 = fib2, fib1 + fib2
    return fib2
```

## Восстановление пути

В некоторых задачах, помимо ответа, требуется восстановить путь, по которому был получен ответ. Есть два способа
восстановления пути.

* **По таблице ответов.** После того как таблица ответов заполнена, можно начать самостоятельно восстанавливать путь,
  используя информацию о предыдущих подзадачах. Для этого нужно начать с конечной подзадачи и двигаться к начальной,
  пока не дойдем до нее. Переход к следующей подзадаче происходит по информации в таблице ответов.

* **По таблице предков.** Помимо таблицы ответов будем поддерживать таблицу предков, где для каждой подзадачи
  хранится номер предыдущей подзадачи, которая привела к текущему ответу. Затем можно восстановить путь, начиная с
  конечной подзадачи и двигаясь к начальной, пока не дойдем до нее. Переход к следующей подзадаче происходит по
  информации в таблице предков.

Часто восстановление пути по таблице предков проще и удобнее, так как не нужно самостоятельно восстанавливать путь по
таблице ответов. При этом, таблица предков требует дополнительной памяти для хранения информации о предыдущих
подзадачах.
