"""
https://kompege.ru/task, 2363

Дана последовательность N натуральных чисел. Рассматриваются все её непрерывные подпоследовательности длиной
не менее пяти элементов, такие что сумма элементов каждой из них кратна k. Найдите количество таких
подпоследовательностей. Гарантируется, что хотя бы одна подпоследовательность удовлетворяет условиям.

Входные данные
Даны два входных файла (файл A и файл B), каждый из которых содержит в первой строке делитель k
(2 <= k <= 10000) и количество чисел N (1 ≤ N ≤ 10 000 000). Каждая из следующих N строк содержит одно
натуральное число, не превышающее 10 000.

Пример организации исходных данных:
117 9
108
129
143
186
72
195
94
38
69

В данной последовательности условиям удовлетворяют подпоследовательности
129, 143, 186, 72, 195, 94;
186, 72, 195, 94, 38;
72, 195, 94, 38, 69

Поэтому ответ для приведённого примера 3

В ответе укажите два числа: сначала значение искомой суммы для файла А, затем – для файла B.
"""

from collections import deque


def k_subarray_naive(k: int, a: list[int]) -> int:
    """Перебор всех подпоследовательностей. Сложность O(N^2)"""
    n = len(a)
    count = 0

    for i in range(n):
        s = 0

        for j in range(i, n):
            s += a[j]

            if s % k == 0 and j - i + 1 >= 5:
                count += 1

    return count


def k_subarray_ps(k: int, a: list[int]) -> int:
    """Префиксные суммы. Сложность O(N)."""
    n = len(a)
    prefix_count = [0] * k
    """prefix_count[i] - количество префиксов с остатком i"""
    count = 0
    s = 0

    # Заполняем очередь первыми 4 префиксами
    queue: deque[int] = deque()
    for i in range(4):
        s += a[i]
        queue.append(s)

    # Подсчитываем количество подпоследовательностей
    for i in range(4, n):
        # Добавляем новый элемент в сумму, теперь в подпоследовательности не менее 5 элементов
        s += a[i]

        # Обновляем количество подходящих подпоследовательностей
        if s % k == 0:
            count += 1

        # Со всеми префиксами того же остатка, что и S можно составить новую подпоследовательность
        count += prefix_count[s % k]

        # Обрабатываем первый префикс в очереди: теперь его можно использовать для составления новых
        # подпоследовательностей.
        prefix_count[queue.popleft() % k] += 1

        # Кладем текущий префикс в очередь
        queue.append(s)

    return count
